#!/usr/bin/env python

import argparse
import glob
import os
import shlex
import subprocess
import sys

top_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
chrome_src = os.environ.get('CHROME_SRC')
if chrome_src:
  chrome_src = os.path.abspath(chrome_src)
if not chrome_src or not os.path.isdir(chrome_src):
  chrome_src = os.path.join(top_dir, '..')
  print 'CHROME_SRC not set, falling back to ' + chrome_src

script_dir = os.path.abspath(os.path.join(chrome_src, 'build'))
if not os.path.isdir(script_dir):
  print script_dir + " is not a valid directory"
  sys.exit(1)

sys.path.insert(0, script_dir)
import gn_helpers


# Add paths so that pymod_do_main(...) can import files.
sys.path.insert(1, os.path.join(chrome_src, 'tools', 'generate_shim_headers'))
sys.path.insert(1, os.path.join(chrome_src, 'tools', 'grit'))

# Remove the above and keep the line below once we require a newer specific
# Chromium revision.
sys.path.insert(1, os.path.join(chrome_src, 'third_party', 'WebKit',
    'Source', 'build', 'scripts'))
sys.path.insert(1, os.path.join(chrome_src, 'chrome', 'tools', 'build'))
sys.path.insert(1, os.path.join(chrome_src, 'native_client', 'build'))

def GetOutputDirectory():
  """Returns the output directory that GN will use."""

  # Handle command line generator flags.
  parser = argparse.ArgumentParser()
  parser.add_argument('-G', dest='genflags', default=[], action='append')
  genflags = parser.parse_known_args()[0].genflags

  # Handle generator flags from the environment.
  genflags += shlex.split(os.environ.get('GN_GENERATOR_FLAGS', ''))

  needle = 'output_dir='
  for item in genflags:
    if item.startswith(needle):
      return item[len(needle):]

  return 'out'


if __name__ == '__main__':
  arg = 0
  args = []
  target_os = 'linux'
  for i in range(len(sys.argv)):
    if arg > 0:
      args[arg] += " " + sys.argv[i];
      if sys.argv[i] in ('target_os="tizen"'):
        target_os = 'tizen'
      continue
    if sys.argv[i] in ("--args="):
      args.append(sys.argv[i])
      arg=i
    else:
      args.append(sys.argv[i])

  # On Mac we want to override CXX and CC that is provided with
  # the Chromium GYP environment.
  if sys.platform.startswith('darwin'):
    os.environ['CXX'] = 'clang++'
    os.environ['CC'] = 'clang'

  #gyp_helper.apply_chromium_gyp_env()

#  args.extend(['-I' + i for i in additional_include_files(args)])

  # On Mac we want to build in x64 mode. And we want to use libc++.
  # Even though we are not on linux, it seems we specifically have to disable linux_use_tcmalloc.
  if sys.platform in ('darwin',):
      args[arg] += " host_arch=\"x64\" use_libcpp=true linux_use_tcmalloc=false"

  # There shouldn't be a circular dependency relationship between .gyp files,
  # but in Chromium's .gyp files, on non-Mac platforms, circular relationships
  # currently exist.  The check for circular dependencies is currently
  # bypassed on other platforms, but is left enabled on the Mac, where a
  # violation of the rule causes Xcode to misbehave badly.
  # TODO(mark): Find and kill remaining circular dependencies, and remove this
  # option.  http://crbug.com/35878.
  # TODO(tc): Fix circular dependencies in ChromiumOS then add linux2 to the
  # list.
  #if sys.platform not in ('darwin',):
  #  args[arg] += " no_circular_check=true"

  # the top_level source directory is the first common ancestor of our module and the chromium source tree for the build to be sane.
  # commonprefix works on a character basis, so it might return a phony common prefix (not the common parent directory we expect),
  toplevel= os.path.commonprefix([top_dir, chrome_src])

  if not os.path.exists(toplevel):
    toplevel = os.path.join(toplevel, os.pardir)
  #args[arg] += " toplevel-dir=\"" + toplevel + "\""
  # Tweak the output location.
  #args[arg] += "generator-output=\"" + os.path.abspath(GetOutputDirectory()) + "\""
  #args[arg] += " Goutput_dir=\"" + os.path.abspath(GetOutputDirectory()) + "\""
  #args[arg] += " check=true"

  # gyp on gbs fails with multiprocessing.SemLock() not implemented
  # disabling parallel gyp for gbs
  gbs_build = os.environ.get('BUILDING_WITH_GBS')
  #if gbs_build:
    #args[arg] += " no-parallel=true"

  os.environ["CHROMIUM_BUILDTOOLS_PATH"]=os.path.join(chrome_src, "buildtools")

  #notifications -> enable_notifications in build/config/features.gni
  #args[arg] += " ewk_bringup=false notifications=false"

  args[arg] += " gcc_version=49"  # It should be in condition for arm target

  args.append("--defines=USE_EFL")
#  args.append("-v")

  buildtools_path = os.environ.get('CHROMIUM_BUILDTOOLS_PATH')
  host_arch = os.environ.get('HOST_ARCH')
  if not buildtools_path:
    print "build tool path is empty"
    sys.exit(1)
  else:
    if sys.platform.startswith(('cygwin', 'win')):
      subdir = 'win'
    elif sys.platform == 'darwin':
      subdir = 'mac'
    elif target_os == 'linux':
      subdir = 'linux64'
    elif target_os == 'tizen':
      buildtools_path = os.path.join(buildtools_path, "../tizen_src/")
      subdir = 'buildtools'
    else:
      raise Error('The subdir is not set.')

    bin_path = os.path.join(buildtools_path, subdir)

    exeSuffix = ''
    if sys.platform.startswith(('cygwin', 'win')):
      exeSuffix = '.exe'
    elif target_os == 'linux' or target_os == 'tizen':
      exeSuffix = ''

    gn_path = os.path.join(bin_path, 'gn' + exeSuffix)
    if not os.path.exists(gn_path):
      print 'Could not find gn executable at: %s' % gn_path
      sys.exit(2)
    else:
      print 'Updating projects from gn files...'
      sys.exit(subprocess.call([gn_path] + args[1:]))
